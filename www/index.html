<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Native WebGPU Morphology</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
      }
      #ui {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
      }
      button {
        padding: 10px 20px;
      }
      button.active {
        background: #2a7fff;
        color: white;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <button id="none" class="active">Original</button>
      <button id="white">White TopHat</button>
      <button id="black">Black TopHat</button>
      <button id="threshold">Threshold (Auto)</button>
    </div>

    <canvas id="gpuCanvas"></canvas>

    <script type="module">
      if (!navigator.gpu) {
        alert("WebGPU not supported");
        throw "";
      }

      // ---------------- CAMERA ----------------
      const video = document.createElement("video");
      video.autoplay = true;
      video.playsInline = true;

      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: 1280, height: 720 },
      });

      video.srcObject = stream;
      await video.play();

      const width = video.videoWidth;
      const height = video.videoHeight;

      // ---------------- WEBGPU SETUP ----------------
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();

      const canvas = document.getElementById("gpuCanvas");
      canvas.width = width;
      canvas.height = height;

      const context = canvas.getContext("webgpu");
      const format = navigator.gpu.getPreferredCanvasFormat();

      context.configure({
        device,
        format,
        alphaMode: "opaque",
      });

      // External video texture
      function getVideoTexture() {
        return device.importExternalTexture({
          source: video,
        });
      }

      // Storage texture helper
      function createStorageTexture() {
        return device.createTexture({
          size: [width, height],
          format: "rgba8unorm",
          usage:
            GPUTextureUsage.STORAGE_BINDING |
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.RENDER_ATTACHMENT,
        });
      }

      const grayTex = createStorageTexture();
      const erodeTex = createStorageTexture();
      const dilateTex = createStorageTexture();
      const tempTex = createStorageTexture();
      const resultTex = createStorageTexture();
      const thresholdTex = createStorageTexture();

      const WORKGROUP = 8;
      const K = 3;

      // ---------------- SHADER CREATION ----------------
      function computePipeline(code) {
        return device.createComputePipeline({
          layout: "auto",
          compute: {
            module: device.createShaderModule({ code }),
            entryPoint: "main",
          },
        });
      }

      // ---------- GRAYSCALE ----------
      const grayscalePipeline = computePipeline(`
@group(0) @binding(0) var inputTex : texture_external;
@group(0) @binding(1) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(${WORKGROUP},${WORKGROUP})
fn main(@builtin(global_invocation_id) id : vec3<u32>) {

  let dims = textureDimensions(outTex);
  if (id.x >= dims.x || id.y >= dims.y) { return; }

  let color = textureLoad(inputTex, vec2<i32>(id.xy));
  let g = dot(color.rgb, vec3<f32>(0.299,0.587,0.114));

  textureStore(outTex,
    vec2<i32>(id.xy),
    vec4<f32>(g,g,g,1.0));
}
`);

      // ---------- EROSION ----------
      const erosionPipeline = computePipeline(`
@group(0) @binding(0) var inputTex : texture_2d<f32>;
@group(0) @binding(1) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(${WORKGROUP},${WORKGROUP})
fn main(@builtin(global_invocation_id) id : vec3<u32>) {

  let dims = textureDimensions(outTex);
  if (id.x >= dims.x || id.y >= dims.y) { return; }

  var minVal : f32 = 1.0;

  for (var y:i32=-${K}; y<=${K}; y++) {
    for (var x:i32=-${K}; x<=${K}; x++) {

      let c = vec2<i32>(id.xy) + vec2<i32>(x,y);

      if (c.x < 0 || c.y < 0 ||
          c.x >= i32(dims.x) ||
          c.y >= i32(dims.y)) {
        continue;
      }

      let v = textureLoad(inputTex, c, 0).r;
      minVal = min(minVal, v);
    }
  }

  textureStore(outTex,
    vec2<i32>(id.xy),
    vec4<f32>(minVal,minVal,minVal,1.0));
}
`);

      // ---------- DILATION ----------
      const dilationPipeline = computePipeline(`
@group(0) @binding(0) var inputTex : texture_2d<f32>;
@group(0) @binding(1) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(${WORKGROUP},${WORKGROUP})
fn main(@builtin(global_invocation_id) id : vec3<u32>) {

  let dims = textureDimensions(outTex);
  if (id.x >= dims.x || id.y >= dims.y) { return; }

  var maxVal : f32 = 0.0;

  for (var y:i32=-${K}; y<=${K}; y++) {
    for (var x:i32=-${K}; x<=${K}; x++) {

      let c = vec2<i32>(id.xy) + vec2<i32>(x,y);

      if (c.x < 0 || c.y < 0 ||
          c.x >= i32(dims.x) ||
          c.y >= i32(dims.y)) {
        continue;
      }

      let v = textureLoad(inputTex, c, 0).r;
      maxVal = max(maxVal, v);
    }
  }

  textureStore(outTex,
    vec2<i32>(id.xy),
    vec4<f32>(maxVal,maxVal,maxVal,1.0));
}
`);

      // ---------- SUBTRACTION ----------
      const subtractPipeline = computePipeline(`
@group(0) @binding(0) var a : texture_2d<f32>;
@group(0) @binding(1) var b : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(${WORKGROUP},${WORKGROUP})
fn main(@builtin(global_invocation_id) id : vec3<u32>) {

  let dims = textureDimensions(outTex);
  if (id.x >= dims.x || id.y >= dims.y) { return; }

  let av = textureLoad(a, vec2<i32>(id.xy), 0).r;
  let bv = textureLoad(b, vec2<i32>(id.xy), 0).r;

  let r = max(av - bv, 0.0);

  textureStore(outTex,
    vec2<i32>(id.xy),
    vec4<f32>(r,r,r,1.0));
}
`);

      // ---------- HISTOGRAM ----------
      const histogramPipeline = computePipeline(`
@group(0) @binding(0) var inputTex : texture_2d<f32>;
@group(0) @binding(1) var<storage, read_write> histogram : array<atomic<u32>, 256>;

@compute @workgroup_size(${WORKGROUP},${WORKGROUP})
fn main(@builtin(global_invocation_id) id : vec3<u32>) {

  let dims = textureDimensions(inputTex);
  if (id.x >= dims.x || id.y >= dims.y) { return; }

  let v = textureLoad(inputTex, vec2<i32>(id.xy), 0).r;
  let bin = u32(v * 255.0);
  atomicAdd(&histogram[bin], 1u);
}
`);

      // ---------- THRESHOLDING ----------
      const thresholdPipeline = computePipeline(`
@group(0) @binding(0) var inputTex : texture_2d<f32>;
@group(0) @binding(1) var outTex : texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(2) var<uniform> thresholdValue : f32;

@compute @workgroup_size(${WORKGROUP},${WORKGROUP})
fn main(@builtin(global_invocation_id) id : vec3<u32>) {

  let dims = textureDimensions(outTex);
  if (id.x >= dims.x || id.y >= dims.y) { return; }

  let v = textureLoad(inputTex, vec2<i32>(id.xy), 0).r;
  let bw = select(0.0, 1.0, v > thresholdValue);

  textureStore(outTex,
    vec2<i32>(id.xy),
    vec4<f32>(bw,bw,bw,1.0));
}
`);

      // ---------- THRESHOLD UNIFORM BUFFER ----------
      const thresholdBuffer = device.createBuffer({
        size: 4,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });

      // ---------- HISTOGRAM BUFFER ----------
      const histogramBuffer = device.createBuffer({
        size: 256 * 4,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
        mappedAtCreation: true,
      });
      new Uint32Array(histogramBuffer.getMappedRange()).fill(0);
      histogramBuffer.unmap();

      // ---------- PRESENT PIPELINE ----------
      const renderPipeline = device.createRenderPipeline({
        layout: "auto",
        vertex: {
          module: device.createShaderModule({
            code: `
      @vertex
      fn main(@builtin(vertex_index) i : u32)
        -> @builtin(position) vec4<f32> {

        var pos = array<vec2<f32>,6>(
          vec2(-1,-1), vec2(1,-1), vec2(-1,1),
          vec2(-1,1),  vec2(1,-1), vec2(1,1)
        );

        return vec4(pos[i],0,1);
      }
      `,
          }),
          entryPoint: "main",
        },
        fragment: {
          module: device.createShaderModule({
            code: `
      @group(0) @binding(0) var tex : texture_2d<f32>;
      @group(0) @binding(1) var samp : sampler;

      @fragment
      fn main(@builtin(position) pos : vec4<f32>)
        -> @location(0) vec4<f32> {

        let uv = pos.xy / vec2<f32>(${width}.0, ${height}.0);
        return textureSample(tex, samp, uv);
      }
      `,
          }),
          entryPoint: "main",
          targets: [{ format }],
        },
        primitive: { topology: "triangle-list" },
      });

      const sampler = device.createSampler({
        magFilter: "nearest",
        minFilter: "nearest",
      });

      function computeAutoThreshold() {
        // choose source texture (grayscale or latest morphology result)
        const sourceView =
          lastMorph === "white" || lastMorph === "black"
            ? resultTex.createView()
            : grayTex.createView();

        // Compute histogram to find Otsu threshold
        const histogramGPUBuffer = device.createBuffer({
          size: 256 * 4,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
          mappedAtCreation: true,
        });
        new Uint32Array(histogramGPUBuffer.getMappedRange()).fill(0);
        histogramGPUBuffer.unmap();

        const histBindGroup = device.createBindGroup({
          layout: histogramPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: sourceView },
            { binding: 1, resource: histogramGPUBuffer },
          ],
        });

        const encoder = device.createCommandEncoder();
        const pass = encoder.beginComputePass();
        pass.setPipeline(histogramPipeline);
        pass.setBindGroup(0, histBindGroup);
        pass.dispatchWorkgroups(
          Math.ceil(width / WORKGROUP),
          Math.ceil(height / WORKGROUP),
        );
        pass.end();

        const stagingBuffer = device.createBuffer({
          size: 256 * 4,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
        });
        encoder.copyBufferToBuffer(
          histogramGPUBuffer,
          0,
          stagingBuffer,
          0,
          256 * 4,
        );
        device.queue.submit([encoder.finish()]);

        stagingBuffer.mapAsync(GPUMapMode.READ).then(() => {
          const histogram = new Uint32Array(stagingBuffer.getMappedRange());
          const totalPixels = width * height;

          // Otsu's method
          let sum = 0;
          for (let i = 0; i < 256; i++) {
            sum += i * histogram[i];
          }

          let sumB = 0;
          let countB = 0;
          let maxVariance = 0;
          let threshold = 0;

          for (let t = 0; t < 256; t++) {
            countB += histogram[t];
            if (countB === 0) continue;

            const countF = totalPixels - countB;
            if (countF === 0) break;

            sumB += t * histogram[t];
            const meanB = sumB / countB;
            const meanF = (sum - sumB) / countF;

            const variance =
              countB * countF * (meanB - meanF) * (meanB - meanF);
            if (variance > maxVariance) {
              maxVariance = variance;
              threshold = t;
            }
          }

          device.queue.writeBuffer(
            thresholdBuffer,
            0,
            new Float32Array([threshold / 255.0]),
          );
          stagingBuffer.unmap();
          histogramGPUBuffer.destroy();
          stagingBuffer.destroy();
        });
      }

      let lastThresholdCompute = 0;

      let mode = "none";

      function dispatch(pipeline, bindings) {
        const bindGroup = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: bindings,
        });

        const encoder = device.createCommandEncoder();
        const pass = encoder.beginComputePass();
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(
          Math.ceil(width / WORKGROUP),
          Math.ceil(height / WORKGROUP),
        );
        pass.end();
        device.queue.submit([encoder.finish()]);
      }

      function frame() {
        const videoTex = getVideoTexture();

        // Grayscale
        dispatch(grayscalePipeline, [
          { binding: 0, resource: videoTex },
          { binding: 1, resource: grayTex.createView() },
        ]);

        if (mode === "none") {
          render(grayTex);
          requestAnimationFrame(frame);
          return;
        }

        if (mode === "threshold") {
          // if we previously applied a top-hat, recompute it to keep resultTex up-to-date
          if (lastMorph === "white") {
            // same logic as white mode
            dispatch(erosionPipeline, [
              { binding: 0, resource: grayTex.createView() },
              { binding: 1, resource: erodeTex.createView() },
            ]);
            dispatch(dilationPipeline, [
              { binding: 0, resource: erodeTex.createView() },
              { binding: 1, resource: dilateTex.createView() },
            ]);
            dispatch(subtractPipeline, [
              { binding: 0, resource: grayTex.createView() },
              { binding: 1, resource: dilateTex.createView() },
              { binding: 2, resource: resultTex.createView() },
            ]);
          } else if (lastMorph === "black") {
            // same logic as black mode
            dispatch(dilationPipeline, [
              { binding: 0, resource: grayTex.createView() },
              { binding: 1, resource: tempTex.createView() },
            ]);
            dispatch(erosionPipeline, [
              { binding: 0, resource: tempTex.createView() },
              { binding: 1, resource: dilateTex.createView() },
            ]);
            dispatch(subtractPipeline, [
              { binding: 0, resource: dilateTex.createView() },
              { binding: 1, resource: grayTex.createView() },
              { binding: 2, resource: resultTex.createView() },
            ]);
          }

          // Compute threshold every 10 frames
          lastThresholdCompute++;
          if (lastThresholdCompute > 10) {
            computeAutoThreshold();
            lastThresholdCompute = 0;
          }

          // pick input based on lastMorph
          const inputView =
            lastMorph === "white" || lastMorph === "black"
              ? resultTex.createView()
              : grayTex.createView();

          dispatch(thresholdPipeline, [
            { binding: 0, resource: inputView },
            { binding: 1, resource: thresholdTex.createView() },
            { binding: 2, resource: thresholdBuffer },
          ]);

          render(thresholdTex);
          requestAnimationFrame(frame);
          return;
        }

        // Opening
        dispatch(erosionPipeline, [
          { binding: 0, resource: grayTex.createView() },
          { binding: 1, resource: erodeTex.createView() },
        ]);

        dispatch(dilationPipeline, [
          { binding: 0, resource: erodeTex.createView() },
          { binding: 1, resource: dilateTex.createView() },
        ]);

        if (mode === "white") {
          dispatch(subtractPipeline, [
            { binding: 0, resource: grayTex.createView() },
            { binding: 1, resource: dilateTex.createView() },
            { binding: 2, resource: resultTex.createView() },
          ]);
        }

        if (mode === "black") {
          dispatch(dilationPipeline, [
            { binding: 0, resource: grayTex.createView() },
            { binding: 1, resource: tempTex.createView() },
          ]);

          dispatch(erosionPipeline, [
            { binding: 0, resource: tempTex.createView() },
            { binding: 1, resource: dilateTex.createView() },
          ]);

          dispatch(subtractPipeline, [
            { binding: 0, resource: dilateTex.createView() },
            { binding: 1, resource: grayTex.createView() },
            { binding: 2, resource: resultTex.createView() },
          ]);
        }

        render(resultTex);
        requestAnimationFrame(frame);
      }

      function render(tex) {
        const view = context.getCurrentTexture().createView();

        const bindGroup = device.createBindGroup({
          layout: renderPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: tex.createView() },
            { binding: 1, resource: sampler },
          ],
        });

        const encoder = device.createCommandEncoder();
        const pass = encoder.beginRenderPass({
          colorAttachments: [
            {
              view,
              loadOp: "clear",
              storeOp: "store",
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
            },
          ],
        });

        pass.setPipeline(renderPipeline);
        pass.setBindGroup(0, bindGroup);
        pass.draw(6);
        pass.end();

        device.queue.submit([encoder.finish()]);
      }

      document.getElementById("none").onclick = () => setMode("none");
      document.getElementById("white").onclick = () => setMode("white");
      document.getElementById("black").onclick = () => setMode("black");
      document.getElementById("threshold").onclick = () => setMode("threshold");

      // remember last morphology choice so threshold can use it
      let lastMorph = "none";
      function setMode(m) {
        // record white/black/none as lastMorph before switching to threshold
        if (m === "white" || m === "black" || m === "none") {
          lastMorph = m;
        }

        mode = m;
        document
          .querySelectorAll("button")
          .forEach((b) => b.classList.remove("active"));
        document.getElementById(m).classList.add("active");

        // Initialize threshold when entering threshold mode
        if (m === "threshold") {
          computeAutoThreshold();
        }
      }

      // Initialize threshold buffer with default
      device.queue.writeBuffer(thresholdBuffer, 0, new Float32Array([0.5]));

      requestAnimationFrame(frame);
    </script>
  </body>
</html>
